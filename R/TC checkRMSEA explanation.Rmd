---
title: "checkRMSEA explanation"
author: "Tanainan Chuanchaiyakul"
output: rmarkdown::github_document
---

The actual code file: https://github.com/Tanainan/statcheck/blob/master/R/TC%20RMSEA%20%2B%2B%20.R

```{r setup, include=FALSE}
library(plyr)
library(dplyr)
library(stringr)

knitr::opts_chunk$set(echo = TRUE)
```

The first part of the code is the same as statcheck, but only different function name.

``` {r eval = FALSE}

checkRMSEA <-
  function(x) {{
    
    # Create empty data frame for main result:
    Res <-
      data.frame(NULL)
    
    class(Res) <- c("checkRMSEA", "data.frame")
    
    if (length(x) == 0)
      return(Res)
    
    if (is.null(names(x)))
      names(x) <-  1:length(x)
    
    message("Extracting statistics...")
    pb <- txtProgressBar(max = length(x), style = 3)
    for (i in 1:length(x)) {
      txt <- x[i]
      
```

Then I changed the function to be able to get Chi2, df, RMSEA, N, etc. from the pdf article.

*** Note that string extraction is not case sensitive 

1)) Fix bugs that occurs when turing a PDF file into a text file. Here, this line of code can fix when the text file shows "1/4" or double spacing, instead of "=", and ":", instead of "." for decimal places. I also change all the square brackets to parentheses to make it easier when extracting the string.

```{r eval = FALSE}

            txt <- unlist(str_replace_all(txt, c("1/4" = "=", "  " = " = ", "\\[" = "(", "\\]" = ")", "(\\:)(\\d)" = ".\\2")))


```

2)) Extract paragraphs that contain "RMSEA", "root mean square error of approximation", "root-mean-square error of approximation" + 20 characters (maximum) after the keyword + RMSEA value. This would indicate that the program will extract the actual results, rather than when a paragraph in the article only introduces model fit criteria.

The RMSEA values that can be extracted with this code are ".05" or ":05". The numbers of decimal places can be anything.


```{r eval = FALSE}
      
      # extract paragraphs containing Chis2-values by locating RMSEA first:
      Loc <- str_subset(txt, regex("(((root mean square error of approximation|root-mean-square error of approximation|\\(?RMSEA\\)?)(.){0,20}(\\.\\d+)))", ignore_case = T))

```
     
     
3)) Sometimes, the text read the "=" as 5. For example, in Hoglund (2007).txt, the text would be RMSEA 5 .043, instead of RMSEA = .43. In Jasuja (2008).txt, it would be RMSEA5.043. 

How the code work is that it looks for the string that contains either:

- chi2 notations which can be in form of v2, c2, w2, x2, or only 2. E.g., v2520. The code will change this to v2 = 20. Another example is "blah blah blah fit: 2 5 23". This one will be "blah blah blah fit: 2 = 23"

- A df that is denoted as "d.f."

- A chi2 that comes after a parentheses. E.g., "w2 (df 5 24, N 5 337) 5 31.45" -> "w2 (df = 24, N = 337) = 31.45"

- Anything that ends with an alphabet, then 5, then numbers. E.g., "n5443" -> "n = 443"; "root mean ... approximation5.98" -> "root mean ... approximation = .98"

We need to change it because, later, we need to extract a number from the string, and 5 would also be extracted (which it shouldn't be). 

```{r eval = FALSE}
      Loc <- unlist(str_replace_all(Loc, c("([vcwx]2|(\\:|\\(|\\d|\\,)\\s2|[a-zA-Z]|f\\.|\\))(5)((\\d*\\.\\d+)|\\d+)" = "\\1 = \\4")))
      Loc <- unlist(str_replace_all(Loc, c("([vcwx]2|(\\:|\\(|\\d|\\,)\\s2|[a-zA-Z]|f\\.|\\))( 5 )((\\d*\\.\\d+)|\\d+)" = "\\1 = \\4")))

```

In some cases, RMSEA result is reported/mentioned BEFORE chi2 value. I structured the code to look for when chi2 is reported BEFORE RMSEA first. If the amounts of chi2 and RMSEA extracted match, then it won't look for when RMSEA is before chi2. However, this might not be efficient when the amounts of chi2 and RMSEA match, and there is also RMSEA reported before chi2. 

4)) Extract chi2 and RMSEA results as a whole sentence from Loc. Possible notations of chi2 that this code can get are:

1) chi square
2) chi-square of
3) chisquare
4) v2
5) c2
6) w2
7) x2
8) 2 -> I set a condition that 2 must be after ":", "(", a comma, or any number, then 2, then followed by "(" or "=". E.g., "N = 25, 2 = 3, df = 56" -> then we know that "2" is the chi2.
9) Av2
10) Ac2
11) Aw2
12) Ax2
13) Dv2
14) Dc2
15) Dw2
16) Dx2

The fillers include : "=", "of", "(" -> a space between a chi2 notation and a filler is flexible, especially for "=" and "("
E.g., "c2(...) = 45" or "v2=334"


** From 9) to 16) are chi2 difference/delta. The results will be omitted later. I cannot make the code to only collect v2 = ..., but not Dv2 = ... For example, the text might be "Dv2 = 33". If I don't specify the "D" in front of chi2, it will only get "v2 = 33", which we cannot know if it's actually v2 or Dv2.

The code below would get a whole chunk of chi2 = .... RMSEA = ....

E.g., "w2 (df = 24, N = 337) = 38.97, po.05; CFI = .968; RMSEA = .043."

#### This string matching can definitely be improved.

```{r eval = FALSE}

# If Chi2 is reported before RMSEA ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      CR <- str_extract_all(unlist(Loc), regex("((chi-square (?!difference)|chisquare|chi-square of|A?D?[vcwx]2\\s?(=|\\(|of)|(\\:|\\(|\\d|\\,)\\s?2\\s?(\\(|\\=))(.){0,40}((\\d*\\,?\\d*\\.\\d+)|\\d*\\,?\\d+)(.){0,300}(root mean square error of approximation|root-mean-square error of approximation|RMSEA)\\s(.){0,40}\\s(0?\\.\\d+))", ignore_case = TRUE))
      CR1 <- str_extract_all(unlist(CR), regex("((chi-square (?!difference)|chisquare|chi-square of|A?D?[vcwx]2\\s?(=|\\(|of)|(\\:|\\(|\\d|\\,)\\s?2\\s?(\\(|\\=))(.){0,40}((\\d*\\,?\\d*\\.\\d+)|\\d*\\,?\\d+)(.){0,20})", ignore_case = TRUE))



```


5)) Remove irrelevant info to make it easier to get the right chi2 value, especially when there's () between the chi2 symbol and the chi2 value. E.g., "w2 (df = 24, N = 337) = 38.97" -> the program might mistakenly read 24 or 337 as chi2 values. We changeything in the parentheses into "".

E.g., "w2 (df = 24, N = 337) = 38.97" -> "w2 = 38.97"

This is only for when there is df, n, and/or p-value in parentheses between a chi2 notation and a chi2 value.

Remove "," between numbers.


```{r eval = FALSE}

      CR2 <- str_replace_all(unlist(CR1), c("\\((.){1,20}\\)" = "", "\\s\\s" = " ", "(\\d)(\\,)(\\d)" = "\\1\\3"))

```

6)) Make a sentence about chi2 shorter to make it easier to get the value.


```{r eval = FALSE}

      CR3 <- str_extract_all(unlist(CR2), regex("((chi-square (?!difference)|chisquare|chi-square of|A?D?[vcwx]2\\s?(=|\\(|of)|(\\:|\\(|\\d|\\,)\\s?2\\s?(\\(|\\=))(.){0,20}((\\d*\\.\\d+)|\\d+))", ignore_case = TRUE))

      CR4 <- str_replace_all(unlist(CR3), c("[vcwx]2|(\\:|\\(|\\d|\\,)\\s2\\s" = ""))


```


7)) Change all the chi2 difference extracted to NA by replacing the string with an empty string


```{r eval = FALSE}

      CR5 <- str_replace_all(unlist(CR4), "^[AD].*", "")

```

8)) Get the chi2 value

We prevent the program to collect the chi2 notation of "2" and only get the actual chi2 value. The value can have any numbers of decimal places (e.g., 3.444), only have the decimal places (e.g., .56), or no decimal places (e.g., 456).

```{r eval = FALSE}

      CChi2 <- unlist(str_extract(unlist(CR5), regex("(?!(2\\s))((\\d*\\.\\d+)|\\d+)")))


```

9)) If the chi2 values found is equal to the number of original text of chi2, create a data frame that contains a column of chi2 values and a column of original text of chi2. I remove a row for chi2 difference (NA from Step 6). If the chi2 values found and the number of original text don't match, then the data frame is  NULL.

I have to create a data frame because I need to match the original text with the right chi2 value when a listwise deletion is needed for the chi2 difference. 

```{r eval = FALSE}

      if (length(CChi2) == length(unlist(CR1))){
        C <- data.frame(Chi2.Raw = unlist(CR1), Chi2 = unlist(CChi2))
        C <- na.omit(C)
      } else {C <- data.frame(NULL)}

```


10)) Extract df from the sentence of chi2 report. This code can extract df in notations of:

Starting with "(" (e.g., "v2(df = 24, n = 164)"), or a space (e.g., "v2 = 34, df = 45")
1) df
2) d.f.
3) d
4) degrees of freedom

With fillers of "=", "<", ">", then followed by a number that starts with anything but 0, and with no decimal places, then a comma (optional).

5) degrees of freedom of

or 

Starting with a value, then

6) df
7) degrees of freedom

or 

8) a value in parentheses e.g., v2(9) = 34.


```{r eval = FALSE}

Cddd <- str_extract_all(unlist(CR), regex("((\\(|\\s)\\(?(df|d|d.f.)\\s?[<>=]?|(2|2\\s)\\(|degrees of freedom of)\\s?(?!0)\\d+\\s?\\,?|\\s?(?!0)\\d+\\s(df|degrees of freedom)|\\(\\d+\\)", ignore_case = T))
      Cddd <- Cddd[!is.na(Cddd)] # remove NAs


```


11)) Extract the df value. This code won't collect "2" from the chi2 notation. E.g., "2(32) = ..." -> only collect "32"

```{r eval = FALSE}

      Cdf <- str_extract_all(unlist(Cddd), regex("(?!2\\s?\\()\\d+"))
      Cdf <- unlist(Cdf[!is.na(Cdf)]) # remove NAs

```

12)) Get RMSEA from the text. 

```{r eval = FALSE}

      Crrr <- str_extract_all(unlist(CR), regex("((root mean square error of approximation|root-mean-square error of approximation|RMSEA)(.){0,10}\\s(0?\\.\\d+))", ignore_case = T))
      Crrr <- Crrr[!is.na(Crrr)]

```

13)) Replace " , " with "<" -> I found this bug from one of the text files but do not know if it's always the case that "<" will be read as " , " (note that there are space around the comman).

Then extract the RMSEA value. This value is less than 1 always.

```{r eval = FALSE}

      Crrr <- unlist(str_replace_all(unlist(Crrr), c(" , " = " < ")))
      
      CRMSEA <- unlist(str_extract_all(unlist(Crrr), regex("\\.\\d+")))
      CRMSEA <- unlist(CRMSEA[!is.na(CRMSEA)])

```

14)) In case that the number of RMSEA extracted and the number of chi2 get are not the same (due to having a longer report and RMSEA value is too far apart from the RMSEA keyword), we try to collect the RMSEA again with more characters allowed in the string.

```{r eval = FALSE}

if (length(CRMSEA) != length(CChi2)){
        Crrr <- str_extract_all(unlist(CR), regex("((root mean square error of approximation|root-mean-square error of approximation|RMSEA)(.){0,20}\\s(0?\\.\\d+))", ignore_case = T))
        Crrr <- Crrr[!is.na(Crrr)]
        Crrr <- unlist(str_replace_all(unlist(Crrr), c(" , " = " < ")))
        CRMSEA <- unlist(str_extract(unlist(Crrr), regex("\\.\\d+")))
        CRMSEA <- unlist(CRMSEA[!is.na(CRMSEA)]) 
      }

```

15)) Collect RMSEA directional sign "<", ">", "=". If it is written in word, I replace it with a symbol.

```{r eval = FALSE}

 Csign <- str_extract(unlist(Crrr), regex("[=<>]|less than|greater than|equals to|equal to|\\s\\s"))
      Csign <- unlist(Csign[!is.na(Csign)])
      Csign <- Csign %>% str_replace_all(c("less than" = "<", "greater than" = ">", "(equals|equal) to" = "=", "  " = "=")) %>% unlist()

```

16)) Occasionally, there's no sign. E.g., "root mean.... approximation (.56)". I test if the number of RMSEA values found is the same as the number of chi2 values found. If yes, then assume that it an "=" E.g., "= .56" 

```{r eval = FALSE}

if (length(Csign) == 0 & length(CRMSEA) != 0){
        Csign <- rep("=", length(CRMSEA))
      }   

```

17)) Try to get N from the reported sentence. E.g., "w2 (df = 24, N = 337) = 38.97". This code will look for a string that has non-alphabet + n + space (optional) + equal + space (optional) + a number.

The "\\W" is non-alphabet
E.g., "(n equals 23)", ":n = 32", ", N=44"

```{r eval = FALSE}

Cnnn <- str_extract_all(unlist(CR), regex("(\\Wn\\s?(\\=|equals to|equal to|equal|equals)?\\s?\\d*\\,?\\d+)", ignore_case = T))
      Cnnn <- Cnnn[!is.na(Cnnn)]
      CN <- str_extract_all(unlist(Cnnn), regex("\\d*\\,?\\d+"))
      CN <- unlist(CN[!is.na(CN)])

```

18)) Change everything to a vector; remove "," from the chi2, if there's any.

```{r eval = FALSE}

      Chi2 <- list(as.vector(C$Chi2)) %>% unlist 
      df <- list(Cdf) %>% unlist 
      sign <- list(Csign) %>% unlist 
      Chi2.Raw <- list(as.vector(C$Chi2.Raw)) %>% unlist 
      RMSEA <- list(CRMSEA) %>% unlist 
      N <- list(CN) %>% unlist 
      N <- unlist(str_replace_all(unlist(N), "\\,", ""))
      nnn <- list(Cnnn) %>% unlist

```

19)) In case that the amount of chi2 values is not the same as the amount of RMSEA values, try to search for when RMSEA is reported BEFORE the chi2. All steps are the same as above.

```{r eval = FALSE}

      if (length(Chi2) != length(RMSEA)){
        
      RC <- unlist(str_extract_all(unlist(Loc), regex("((root mean square error of approximation|root-mean-square error of approximation|RMSEA)(.){0,20}(0?\\.\\d+)(.){0,80}(chi-square (?!difference)|chiquare|chi-square of|A?D?[vcw]2\\s?\\=?\\s?\\(|(\\:|\\(|\\d|\\,)\\s?2\\s?(\\(|\\=))(.){0,40}((\\d*\\,?\\d*\\.\\d+)|\\d*\\,?\\d+))(.){0,30}", ignore_case = T)))
      RC1 <- str_extract_all(unlist(CR), regex("((chi-square (?!difference)|chisquare|chi-square of|A?D?[vcwx]2\\s?(=|\\(|of)|(\\:|\\(|\\d|\\,)\\s?2\\s?(\\(|\\=))(.){0,40}((\\d*\\,?\\d*\\.\\d+)|\\d*\\,?\\d+)(.){0,30})", ignore_case = TRUE))
      
      # Get Chi2 
      RC2 <- str_replace_all(unlist(RC1), c("\\((.){1,20}\\)" = "", "\\s\\s" = " ", "(\\d)(\\,)(\\d)" = "\\1\\3"))
      RC3 <- str_extract_all(unlist(RC2), regex("((chi-square (?!difference)|chisquare|chi-square of|A?D?[vcwx]2\\s?(=|\\(|of)|(\\:|\\(|\\d|\\,)\\s?2\\s?(\\(|\\=))(.){0,20}((\\d*\\.\\d+)|\\d+))", ignore_case = TRUE))
      RC4 <- str_replace_all(unlist(RC3), c("[vcwx]2|(\\:|\\(|\\d|\\,)\\s2\\s" = ""))
      RC5 <- str_replace_all(unlist(RC4), "^[AD].*", "") # remove Chi2 difference
      RChi2 <- unlist(str_extract(unlist(RC5), regex("(?!(2\\s))((\\d*\\.\\d+)|\\d+)")))
     
      if (length(RChi2) == length(unlist(RC1))){
      R <- data.frame(Chi2.Raw = unlist(RC1), Chi2 = unlist(RChi2)) # create a data frame
      R <- na.omit(R)} else {R <- data.frame(NULL)}
      
      # Get df
      Rddd <- str_extract_all(unlist(RC), regex("((\\(|\\s)\\(?(df|d|d.f.)\\s?[<>=]?|(2|2\\s)\\(|degrees of freedom of)\\s?(?!0)\\d+\\s?\\,?|\\s?(?!0)\\d+\\s(df|degrees of freedom)|\\(\\d+\\)", ignore_case = T))
      Rddd <- Rddd[!is.na(Rddd)]
      Rdf <- str_extract_all(unlist(Rddd), regex("(?!2\\s?\\()\\d+"))
      Rdf <- unlist(Rdf[!is.na(Rdf)])
      
    
      # Get RMSEA
      Rrrr <- str_extract_all(unlist(RC1), regex("((root mean square error of approximation|root-mean-square error of approximation|RMSEA)(.){0,10}\\s(0?\\.\\d+))", ignore_case = T))
      Rrrr <- Rrrr[!is.na(Rrrr)]
      Rrrr <- unlist(str_replace_all(unlist(Rrrr), c(" , " = " < ")))
      RRMSEA <- unlist(str_extract_all(unlist(Rrrr), regex("\\.\\d+")))
      RRMSEA <- unlist(RRMSEA[!is.na(RRMSEA)])
      
      if (length(RRMSEA) != length(RChi2)){
        Rrrr <- str_extract_all(unlist(RC), regex("((root mean square error of approximation|root-mean-square error of approximation|RMSEA)(.){0,20}\\s(0?\\.\\d+))", ignore_case = T))
        Rrrr <- Rrrr[!is.na(Rrrr)]
        Rrrr <- unlist(str_replace_all(unlist(Rrrr), c(" , " = " < ")))
        RRMSEA <- unlist(str_extract(unlist(Rrrr), regex("\\.\\d+")))
        RRMSEA <- unlist(RRMSEA[!is.na(RRMSEA)]) 
      }
      
      # See if reported RMSEA has =,< or > sign
      Rsign <- str_extract(unlist(Rrrr), regex("[=<>]|less than|greater than|equals to|equal to|\\s\\s"))
      Rsign <- unlist(Rsign[!is.na(Rsign)])
      Rsign <- Rsign %>% str_replace_all(c("less than" = "<", "greater than" = ">", "(equals|equal) to" = "=", "  " = "=")) %>% unlist()
      if (length(Rsign) == 0 & length(RRMSEA) != 0){
        Rsign <- rep("=", length(RRMSEA))
      }    
      
      # Get N from when it is reported in the result
      Rnnn <- str_extract_all(unlist(RC), regex("(\\Wn\\s?(\\=|equals to|equal to|equal|equals)?\\s?\\d+)", ignore_case = T))
      Rnnn <- unlist(Rnnn[!is.na(Rnnn)])
      RN <- unlist(str_extract_all(unlist(Rnnn), regex("\\d+")))
      RN <- unlist(RN[!is.na(RN)])
      
      
      # Combine everything ++++++++++++++++++++++++++++++++++++++++++++++++
      Chi2 <- list(as.vector(R$Chi2),as.vector(C$Chi2)) %>% unlist 
      df <- list(Rdf,Cdf) %>% unlist 
      sign <- list(Rsign,Csign) %>% unlist 
      Chi2.Raw <- list(as.vector(R$Chi2.Raw),as.vector(C$Chi2.Raw)) %>% unlist 
      RMSEA <- list(RRMSEA,CRMSEA) %>% unlist 
      N <- list(RN,CN) %>% unlist 
      N <- unlist(str_replace_all(unlist(N), "\\,", ""))
      nnn <- list(Rnnn,Cnnn) %>% unlist
      
      }


```

20)) Check if there's any multi-group keyword mentioned in the article. If yes, search for any possible numbers of the group by looknig for a word "groups" first, and then get the numbers written in words around that are close to the word "groups" (e.g., about 15 characters before and after the keyword). Here, I assume that there shouldn't be more than 10 groups. This method is still not sufficient, especially when they don't mention the number of the group in the text at all (e.g., gender).

```{r eval = FALSE}

      multi <- unlist(str_detect(txt, regex("multigroup|multi-group|multiple (groups|group)|multi-sample|multiple (samples|sample)|multisample|invar", ignore_case = T)))

if (length(which(multi == TRUE)) >= 1){
      ngroup <- unlist(str_extract_all(txt, regex("(.){1,15}(groups|samples)(?!\\.)(.){1,15}", ignore_case = T)))
      ngroup <- unlist(str_extract_all(ngroup, regex("2|3|4|5|6|7|8|9|10|two|three|four|five|six|seven|eight|nine|\\sten\\s")))
      ngroup <- ngroup %>% str_replace_all(c("two" = "2", "three" = "3", "four" = "4", "five" = "5", "six" = "6", "seven" = "7", "eight" = "8", "nine" = "9", "\\sten\\s" = "10")) %>% unlist()
      ngroup <- ngroup[!duplicated(ngroup)]
      } else {ngroup = NULL}
      ngroup <- ngroup[!(as.numeric(ngroup) > 10)]

```

21)) RMSEA computation & comparison. 

If chi2 value is found at least one, if a number of chi2 = df = RMSEA = comparison sign of RMSEA, then we can compute the RMSEA. 

```{r eval = FALSE}

chi2RMSEA <- NULL
      if (length(Chi2) != 0){
        if (length(df) == length(Chi2)){
          if (length(RMSEA) == length(Chi2)){
            if (length(sign) == length(RMSEA)){
      # ++++++++++++++++++++++++++++++++++++

```

22)) The coputation requires a value of N which is not always mentioned in the result. I create 2 cases: a case when a number of chi2 found = a number of N found (e.g., "w2 (df = 24, N = 337) = 38.97"), and a case when they are not equal.

This is the first case.

```{r eval = FALSE}

if (length(N) == length(Chi2)){

```

22.1)) If the number of groups from the multi-group keyword is found, I create a data frame with a number of row of a number of chi2 values * a number of a number of groups. For example, if ngroup = c(4, 5), then we repeat rows of  chi2, df, RMSEA, etc. twice in the data frame. This is for the computation which requires a number of groups.

```{r eval = FALSE}

if (length(ngroup) != 0){
        chi2RMSEA <- data.frame(Chi2 = rep(Chi2, length(ngroup)), df = rep(df, length(ngroup)), N = rep(N, length(ngroup)), Reported.RMSEA = rep(RMSEA, length(ngroup)), Chi2.Raw = rep(unlist(Chi2.Raw), length(ngroup)), Multi.group = rep(ngroup, each = length(Chi2)), N.Raw = rep(unlist(nnn), length(ngroup))))
      }

```

22.2)) If ngroup = 0, then the data frame has # rows = # chi2.


```{r eval = FALSE}

if (length(ngroup) == 0){
        chi2RMSEA <- data.frame(Chi2 = Chi2, df = df, N = N, Reported.RMSEA = RMSEA, Chi2.Raw = unlist(Chi2.Raw), Multi.group = rep("-", length(Chi2)), N.Raw = unlist(nnn))
      }

```

22.3)) Make chi2, df, N, reported.RMSEA numeric for the computation.

```{r eval = FALSE}

      chi2RMSEA$Chi2 <- chi2RMSEA$Chi2 %>% as.character() %>% as.numeric()
      chi2RMSEA$df <- chi2RMSEA$df %>% as.character() %>% as.numeric()
      chi2RMSEA$N <- chi2RMSEA$N %>% as.character() %>% as.numeric()
      chi2RMSEA$Reported.RMSEA <- chi2RMSEA$Reported.RMSEA %>% as.character() %>% as.numeric()

```

22.4)) Add a column of whether there's multi-group word mentioned in the article or not. If there is, then fill that column with # groups and make it numeric. Otherwise print "-".

```{r eval = FALSE}

 if (length(ngroup) != 0){
      chi2RMSEA$Multi.group <- chi2RMSEA$Multi.group %>% as.character() %>% as.numeric()
      } else {chi2RMSEA$Multi.group <- "-"}


```

22.5)) Create new columns for the results of computation, including how many model results and Ns can we get from the text.

```{r eval = FALSE}

      chi2RMSEA$rmsea <- NA
      chi2RMSEA$RMSEA <- NA
      chi2RMSEA$MG.rmsea <- NA
      chi2RMSEA$MG.RMSEA <- NA
      
      #Number of Ns found in the article
      chi2RMSEA$Total.Ns <- length(chi2RMSEA$N)
      
      #Number of models found in the article
      chi2RMSEA$Total.Models <- length(unlist(Chi2.Raw))
      
      chi2RMSEA$Sign = sign


```

22.6)) Compute RMSEA with a for loop.

The first part is to read how many decimal places of RMSEA were reported in the article. We need this info later when comparing for consistency of reported and computed RMSEAs.

The second part is the regular RMSEA computation. Rounded with the decimal places we get from the first part. The results of regular RMSEA computation will be in rmsea (not rounded) and RMSEA (rounded) columns

The third part is for when multi-group is identified. The result of this computation will be in MG.rmsea and MG.RMSEA columns. If ngroup is not found, then it's "-".

** This requires a function from "TC numbers.R" file 

```{r eval = FALSE}

for (j in 1:nrow(chi2RMSEA)){
        deci <- decimalplaces(chi2RMSEA$Reported.RMSEA[j])
        
        chi2RMSEA$rmsea[j] <- sqrt(max(c((chi2RMSEA$Chi2[j]-chi2RMSEA$df[j])/(chi2RMSEA$df[j]*(chi2RMSEA$N[j]-1)),0)))
        chi2RMSEA$RMSEA[j] <- round((chi2RMSEA$rmsea[j]),deci)
        
        if (length(ngroup) != 0){
          chi2RMSEA$MG.rmsea[j] <- sqrt(max(c((chi2RMSEA$Chi2[j]-chi2RMSEA$df[j])/(chi2RMSEA$df[j]*(chi2RMSEA$N[j]-chi2RMSEA$Multi.group[j])),0)))*sqrt(chi2RMSEA$Multi.group[j])
          chi2RMSEA$MG.RMSEA[j] <- round((chi2RMSEA$MG.rmsea[j]),deci)
        }
        if (length(ngroup) == 0){
          chi2RMSEA$MG.rmsea[j] <- "-"
          chi2RMSEA$MG.RMSEA[j] <- "-"
        }
      }

```


22.7)) Test for consistency between reported and computed RMSEAs (and multi-group RMSEAs).
I also refer to the comparison sign extracted from RMSEA in Step 15 and 16.


```{r eval = FALSE}

chi2RMSEA$ConsistencyRMSEA <- NA # test if the reported and computed RMSEAs are the same (same amount of digits as reported)
      chi2RMSEA$ConsistencyMG.RMSEA <- NA
      for (k in 1:nrow(chi2RMSEA)){
        if ((chi2RMSEA$RMSEA[k] == chi2RMSEA$Reported.RMSEA[k]) & chi2RMSEA$Sign[k] == "=") {chi2RMSEA$ConsistencyRMSEA[k] <- "Consistent"} else
        {if ((chi2RMSEA$RMSEA[k] > chi2RMSEA$Reported.RMSEA[k]) & chi2RMSEA$Sign[k] == ">") {chi2RMSEA$ConsistencyRMSEA[k] <- "Consistent"} else
        {if ((chi2RMSEA$RMSEA[k] < chi2RMSEA$Reported.RMSEA[k]) & chi2RMSEA$Sign[k] == "<") {chi2RMSEA$ConsistencyRMSEA[k] <- "Consistent"} else {chi2RMSEA$ConsistencyRMSEA[k] <- "x"}}}
        
        if (length(ngroup) != 0){
        if ((chi2RMSEA$MG.RMSEA[k] == chi2RMSEA$Reported.RMSEA[k]) & chi2RMSEA$Sign[k] == "=") {chi2RMSEA$ConsistencyMG.RMSEA[k] <- "Consistent"} else
        {if ((chi2RMSEA$MG.RMSEA[k] > chi2RMSEA$Reported.RMSEA[k]) & chi2RMSEA$Sign[k] == ">") {chi2RMSEA$ConsistencyMG.RMSEA[k] <- "Consistent"} else
        {if ((chi2RMSEA$MG.RMSEA[k] < chi2RMSEA$Reported.RMSEA[k]) & chi2RMSEA$Sign[k] == "<") {chi2RMSEA$ConsistencyMG.RMSEA[k] <- "Consistent"} else {chi2RMSEA$ConsistencyMG.RMSEA[k] <- "x"}}}
      } else {chi2RMSEA$ConsistencyMG.RMSEA[k] <- "-"}
      }


```


23)) The second case: when # chi2 values is not the same as # of N values retrives.


```{r eval = FALSE}

if (length(N) != length(Chi2)){ # if Ns were not given in the result
      
      N <- NA

```

23.1)) Get the Ns from numbers written in words from the article. 

This code can extract up to 3 digits word. The patterns are:

If there are 3 digits, it will be written as:
"x|z hundred and y"     -> "a hundred and ten",       "eight hundred and ten" 
"x|z hundred and w"     -> "a hundred and sixty",     "eight hundred and sixty"
"x|z hundred and w-z"   -> "a hundred and sixty-two", "eight hundred and sixty-two"
"x|z hundred and z"     -> "a hundred and two",       "eight hundred and two"
"x|z hundred"           -> "a hundred",               "eight hundred" 
"x|z hundred w"         -> "a hundred sixty",         "eight hundred sixty"
"x|z hundred w-z"       -> "a hundred sixty-two",     "eight hundred sixty-two"

We don't need to add any restriction for these cases below because they never happen anyway.
"x|z hundred y"         -> "a hundred and ten",       "eight hundred and ten"
"x|z hundred and z"     -> "a hundred two",           "eight hundred two"


where 
x = the, a
y = ten, eleven - nineteen
w = tweenty, thirty, ..., ninety
z = one - nine
"|" = "or"

For 2 digits:
"y"
"w"
"w-z"

For 1 digit:
"z"

So, the code would be "x|z (optional) + hundred (optional) + and (optional) + y|w|w-z|z (optional)"

Then I remove "the" and "a" in front of "hundred. I also remove " and " and "-" because the function that I will use to change to a number cannot read them.

The code won't extract "ten" from "content" or "a tent" because I specifiy that there must be a space between the word.

Some articles have more than 1,000 participants. I believe that if that's the case, they usually are written in numbers (otherwise, it is too long).


```{r eval = FALSE}

# Get Ns from written text numbers
      word <- (unlist(str_extract_all(txt, regex("(((the|a|one|two|three|four|five|six|seven|eight|nine)?\\s)?hundred\\s(and\\s(ten\\W)?)?)?((thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|eleven|twelve)|(((twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety)(\\-?))?(one|two|three|four|five|six|seven|eight|nine)?))?|\\Wten\\W", ignore_case = T))))
      word <- unlist(lapply(word, function(x) x[nchar(x) >= 1]))
      word <- word %>% str_replace_all(c("(a|the) hundred" = "hundred", " and " = " ", "-" = " ", "ten\\s" = "ten", "(ty)(\\w)" = "\\1 \\2")) %>% unlist()

```


23.2)) Convert written words into numbers. I remove the duplicate and assume that sample size must be greater than 10.

The written word itself will be recorded as N.Raw.

** This requires a function from "TC numbers.R" file.


```{r eval = FALSE}
      
      num <- data.frame(N = rep(NA, length(word)), N.Raw = rep(NA, length(word)))
      for (n in 1:length(word)){
        num$N[n] <- unlist(word2num(word[n])[2]) %>% as.character() %>% as.numeric()
        num$N.Raw[n] <- unlist(word2num(word[n])[1])
      }
      num <- num[!(as.numeric(num$N) < 10),]
      num <- num[!duplicated(num$N),]

```


23.3)) Another way to get Ns is by searching for any numbers in the article.

First, numbers are extracted from a string that says "n=..."; "n equals to ...", or any numbers that are between words (e.g., "include 549 teachers"), or after a word and a comma (e.g., "in total, 16 were graduate students"). I prevent the program to pick up, for example, "2" from "teachers 54 A2". 

I set the minimum digits at 2 (i.e., assuming N > 10). This includes when there are more than a thousand participants, there will be "," between the second and third digits. It won't extract a year of publication and degrees of freedom.
Duplicates are removed.

The string itself will be recorded as N.Raw.

I created the data frame for N and N.Raw in order to remove the duplicates of Ns and Ns that are less than 10.

```{r eval = FALSE}

      # Get location of sample size (from all the integers in the article)
      #N.Raw <- str_extract_all(txt, regex("(n\\s?(\\=|equals to|equal to|equal|equals)\\s?\\d*\\,?\\d+\\)?\\,?\\s)|((?!\\d+)\\w+\\,?\\s(?!0)\\d*\\,?\\d+\\s(?!\\d+)(?!(degrees|a\\s))\\w+)", ignore_case = T)) # search for numbers and get the location in the article
      N.Raw <- str_extract_all(txt, regex("(n\\s?(\\=|equals to|equal to|equal|equals)\\s?\\d*\\,?\\d+)|((?!\\d+)\\w+\\,?\\s(?!0)(\\d+\\,)?\\d{2,3}\\s(?!\\d+)(?!(degrees|a\\s|Jan|Feb|March|April|May|June|July|Augu|Sep|Oct|Nov|Dec|items|days|to\\s|years|months))\\w+)", ignore_case = T)) # search for numbers and get the location in the article
      N.Raw <- unlist(N.Raw[!is.na(N.Raw)])
      N.Raw <- unlist(N.Raw[!duplicated(N.Raw)])

      # Get Ns 
      N <- unlist(str_replace_all(unlist(N.Raw), "(\\d)(\\,)(\\d)", "\\1\\3"))
      # N <- unlist(str_extract_all(unlist(N.Raw), regex("\\W\\d*\\,?\\d+\\W")))
      # N <- unlist(str_extract_all(unlist(N), regex("\\d*\\,?\\d+")))
      N <- unlist(str_extract_all(unlist(N), regex("\\s((\\d*\\,?\\d+)|((?!0)(\\d+\\,)?\\d{2,3}))")))
      N <- unlist(str_replace_all(unlist(N), "\\s", ""))
      N <- unlist(N[!is.na(N)])
      
      nn <- data.frame(N = N, N.Raw = N.Raw)
      nn <- distinct(nn, N, .keep_all = T) # remove duplicates
      nn <- nn[!(as.numeric(as.character(nn$N)) < 10),]

```


23.4)) Combine Ns and N.Raw; remove "," from the number. We cannot do this earlier because the program will pick up years (e.g., 2008) too. Keeping "," is to minimize the amount of numbers found. 


```{r eval = FALSE}

      # Get N.Raws from written text and numbers
      N.Raw <- list(as.vector(nn$N.Raw),as.vector(num$N.Raw)) %>% unlist 
      
      # Combine text and numbers
      N <- list(as.vector(nn$N),as.vector(num$N)) %>% unlist
      N <- unlist(str_replace_all(unlist(N), "\\,", ""))


```

23.5)) Create a data frame, accounting for # of Ns and # of ngroup.

If multi-group is found in the article: 

The total amount of rows will be # of chi2 values * # of Ns and # of ngroup. Here, we need to pay attention to how each value is repeated in order to have different combinations. For example, if chi2 values extracted are 2,3,4. 
Ns extracted are 10,20,30,40. ngroups are 8,9. (df and RMSEA always go together with chi2 because they are from the same result sentence). 

Then we will have 24 rows with unique combinations of:

```{r eval = FALSE}
    
      chi2     Ns    ngroup

1     2       10      8
2     3       10      8
3     4       10      8
4     2       10      9
5     3       10      9
6     4       10      9
7     2       20      8
8     3       20      8
9     4       20      8
10    2       20      9
11    3       20      9
12    4       20      9
13    2       30      8
14    3       30      8
15    4       30      8
16    2       30      9
17    3       30      9
18    4       30      9
19    2       40      8
20    3       40      8
21    4       40      8
22    2       40      9
23    3       40      9
24    4       40      9

```

If multi-group is not found in the article:
The total row is # of chi * # of Ns.


```{r eval = FALSE}

# create a new data frame that can contain all variables
      if (length(ngroup) != 0){
      chi2RMSEA <- data.frame(Chi2 = rep(Chi2, length(N.Raw)*length(ngroup)), df = rep(df, length(N.Raw)*length(ngroup)), Reported.RMSEA = rep(RMSEA, length(N.Raw)*length(ngroup)), Chi2.Raw = rep(unlist(Chi2.Raw), length(N.Raw)*length(ngroup)), Multi.group = rep(ngroup, each = length(Chi2), times = length(N.Raw)))
      
      # add a column for N.Raw (locations)
      chi2RMSEA$N.Raw = rep(N.Raw, each = length(Chi2)*length(ngroup))
      
      # add a column for N
      chi2RMSEA$N = rep(N, each = length(Chi2)*length(ngroup))
      }
      
      if (length(ngroup) == 0){
      chi2RMSEA <- data.frame(Chi2 = rep(Chi2, length(N.Raw)), df = rep(df, length(N.Raw)), Reported.RMSEA = rep(RMSEA, length(N.Raw)), Chi2.Raw = rep(unlist(Chi2.Raw), length(N.Raw)), Multi.group = rep("-", each = length(N.Raw)*length(Chi2)))
     
       # add a column for N.Raw (locations)
      chi2RMSEA$N.Raw = rep(N.Raw, each = length(Chi2))
      
      # add a column for N
      chi2RMSEA$N = rep(N, each = length(Chi2))
      }


```

23.6)) Add columns about total Ns found and total models found in the article.


```{r eval = FALSE}

#Number of Ns found in the article
      if (length(ngroup) != 0){
      chi2RMSEA$Total.Ns <- length(chi2RMSEA$N)/(length(Chi2)*length(ngroup))
      } else {chi2RMSEA$Total.Ns <- length(chi2RMSEA$N)/(length(Chi2))}
      
      #Number of models found in the article
      chi2RMSEA$Total.Models <- length(unlist(Chi2.Raw))

```

23.7)) The rest is the same as Step 22.3-22.8


```{r eval = FALSE}

      chi2RMSEA$Chi2 <- chi2RMSEA$Chi2 %>% as.character() %>% as.numeric()
      chi2RMSEA$df <- chi2RMSEA$df %>% as.character() %>% as.numeric()
      chi2RMSEA$N <- chi2RMSEA$N %>% as.character() %>% as.numeric()
      chi2RMSEA$Reported.RMSEA <- chi2RMSEA$Reported.RMSEA %>% as.character() %>% as.numeric()
      
      if (length(ngroup) != 0){
      chi2RMSEA$Multi.group <- chi2RMSEA$Multi.group %>% as.character() %>% as.numeric()
      } else {chi2RMSEA$Multi.group <- "-"}
      
      chi2RMSEA$Sign = sign
      
      chi2RMSEA$rmsea <- NA
      chi2RMSEA$RMSEA <- NA
      chi2RMSEA$MG.rmsea <- NA
      chi2RMSEA$MG.RMSEA <- NA


      # compute RMSEA
      for (l in 1:nrow(chi2RMSEA)){
        deci <- decimalplaces(chi2RMSEA$Reported.RMSEA[l])
        chi2RMSEA$rmsea[l] <- sqrt(max(c((chi2RMSEA$Chi2[l]-chi2RMSEA$df[l])/(chi2RMSEA$df[l]*(chi2RMSEA$N[l]-1)),0)))
        chi2RMSEA$RMSEA[l] <- round((chi2RMSEA$rmsea[l]),deci)
        if (length(ngroup) != 0){
          chi2RMSEA$MG.rmsea[l] <- sqrt(max(c((chi2RMSEA$Chi2[l]-chi2RMSEA$df[l])/(chi2RMSEA$df[l]*(chi2RMSEA$N[l]-chi2RMSEA$Multi.group[l])),0)))*sqrt(chi2RMSEA$Multi.group[l])
          chi2RMSEA$MG.RMSEA[l] <- round((chi2RMSEA$MG.rmsea[l]),deci)
        }
        if (length(ngroup) == 0){
          chi2RMSEA$MG.rmsea[l] <- "-"
          chi2RMSEA$MG.RMSEA[l] <- "-"
        }
      }
    
          
      chi2RMSEA$ConsistencyRMSEA <- NA # test if the reported and computed RMSEAs are the same (same amount of digits as reported)
      chi2RMSEA$ConsistencyMG.RMSEA <- NA
      for (m in 1:nrow(chi2RMSEA)){
        if ((chi2RMSEA$RMSEA[m] == chi2RMSEA$Reported.RMSEA[m]) & chi2RMSEA$Sign[m] == "=") {chi2RMSEA$ConsistencyRMSEA[m] <- "Consistent"} else
        {if ((chi2RMSEA$RMSEA[m] > chi2RMSEA$Reported.RMSEA[m]) & chi2RMSEA$Sign[m] == ">") {chi2RMSEA$ConsistencyRMSEA[m] <- "Consistent"} else
        {if ((chi2RMSEA$RMSEA[m] < chi2RMSEA$Reported.RMSEA[m]) & chi2RMSEA$Sign[m] == "<") {chi2RMSEA$ConsistencyRMSEA[m] <- "Consistent"} else {chi2RMSEA$ConsistencyRMSEA[m] <- "x"}}}
        
        if (length(ngroup) != 0){
        if ((chi2RMSEA$MG.RMSEA[m] == chi2RMSEA$Reported.RMSEA[m]) & chi2RMSEA$Sign[m] == "=") {chi2RMSEA$ConsistencyMG.RMSEA[m] <- "Consistent"} else
        {if ((chi2RMSEA$MG.RMSEA[m] > chi2RMSEA$Reported.RMSEA[m]) & chi2RMSEA$Sign[m] == ">") {chi2RMSEA$ConsistencyMG.RMSEA[m] <- "Consistent"} else
        {if ((chi2RMSEA$MG.RMSEA[m] < chi2RMSEA$Reported.RMSEA[m]) & chi2RMSEA$Sign[m] == "<") {chi2RMSEA$ConsistencyMG.RMSEA[m] <- "Consistent"} else {chi2RMSEA$ConsistencyMG.RMSEA[m] <- "x"}}}
        } else {chi2RMSEA$ConsistencyMG.RMSEA[m] <- "-"}
         }
      
      } # for length(Chi2) != length(N)
   
      chi2RMSEA$Source = names(x)[i]


```

24. If results are not found or incomplete data, it would print "NA".


```{r eval = FALSE}

}}}  else {if (length(Chi2) != length(df)| length(RMSEA) != length(Chi2)) 
              {chi2RMSEA <- data.frame(Source = names(x)[i], Chi2 = NA, df = NA, N = NA, Multi.group = NA, rmsea = NA, RMSEA = NA, MG.rmsea = NA, MG.RMSEA = NA, Sign = NA, Reported.RMSEA = NA, ConsistencyRMSEA = NA, ConsistencyMG.RMSEA = NA, Chi2.Raw = NA, N.Raw = NA, Total.Ns = NA, Total.Models = NA)}}
        }}

```

25)) The final data frame will be saved as a CSV file.

```{r eval = FALSE}

        
        
          # Append, clean and close:
          Res <- rbind(Res, chi2RMSEA)
          rm(chi2RMSEA)
          
    }
      
      #----------------------
      
      setTxtProgressBar(pb, i)
    }
    close(pb)
    Source <- NULL
  
  
    ###---------------------------------------------------------------------
    
    ### NOTE: adapt to match the empty data frame at the top of the code, and the variables you extracted in the step chi2RMSEA 
    
    # final data frame
    Res <- data.frame(
      Source = Res$Source,
      Chi2 = Res$Chi2,
      df = Res$df,
      N = Res$N,
      Multi.group = Res$Multi.group,
      RMSEA = Res$RMSEA,
      MG.RMSEA = Res$MG.RMSEA,
      Sign = Res$Sign,
      Reported.RMSEA = Res$Reported.RMSEA,
      ConsistencyRMSEA = Res$ConsistencyRMSEA,
      ConsistencyMG.RMSEA = Res$ConsistencyMG.RMSEA,
      Chi2.Raw = Res$Chi2.Raw,
      N.Raw = Res$N.Raw,
      Total.Ns = Res$Total.Ns,
      Total.Models = Res$Total.Models
    )
    

    class(Res) <- c("checkRMSEA", "data.frame")

    ###---------------------------------------------------------------------
    
    # Return message when there are no results
    if (nrow(Res) > 0) {
      write.csv(Res, file = "checkRMSEA results.csv", na = "NA", sep = ",", col.names = T, row.names = T)
     }}


```


For the PDFimport.R file, I only change from "statcheck" to "checkRMSEA" (on the last line at the end of checkPDF and checkPDFdir functions).

```{r eval = FALSE}

getPDF.rmsea <- function(x) #location of PDF
{
  txtfiles <- character(length(x))
  for (i in 1:length(x))
  {
    system(paste('pdftotext -q -enc "ASCII7" "', x[i], '"', sep = ""))
    if (file.exists(gsub("\\.pdf$", "\\.txt", x[i]))) {
      fileName <- gsub("\\.pdf$", "\\.txt", x[i])
      txtfiles[i] <- readChar(fileName, file.info(fileName)$size)
    } else{
      warning(paste("Failure in file", x[i]))
      txtfiles[i] <- ""
    }
  }
  return(txtfiles)
}


## Function to check directory of PDFs:
checkPDFdir.rmsea <- # entire directory
  function(dir,
           subdir = TRUE,
           ...) {
    if (missing(dir))
      dir <- tk_choose.dir()
    
    all.files <-
      list.files(dir,
                 pattern = "\\.pdf",
                 full.names = TRUE,
                 recursive = subdir)
    files <- all.files[grepl("\\.pdf$", all.files)]
    
    if (length(files) == 0)
      stop("No PDF found")
    
    txts <- character(length(files))
    message("Importing PDF files...")
    pb <- txtProgressBar(max = length(files), style = 3)
    for (i in 1:length(files))
    {
      txts[i] <-  getPDF.rmsea(files[i])
      setTxtProgressBar(pb, i)
    }
    close(pb)
    names(txts) <- gsub("\\.pdf$", "", basename(files))
    return(checkRMSEA(txts, ...))
  }

checkPDF.rmsea <-
  function(files, ...) {
    if (missing(files))
      files <- tk_choose.files()
    
    txts <-  sapply(files, getPDF.rmsea)
    names(txts) <-
      gsub("\\.pdf$", "", basename(files), perl = TRUE)
    return(checkRMSEA(txts, ...))
  }



```


When this code does not work:

- When the results are in a table
- When a number of participants change but the final sample size is not reported (e.g., "9 participants were removed from...") (Bassi (2012))
- When it's a multi-group. Sometimes it doesn't say how many groups in number or written word (e.g., gender) and we don't know exactly which model is computed with multi-group. This also includes when the keyword is in the reference.
- The text itself, such as
    - x 2 13 1/4 21:19 (Bakker (2007))
    - v instead of v2 (de Marco (2006))
    - Having no "=" at all (Dunn (2006))
    - Having no chi2 notation at all (Furnham (2009))
    - skip a sentence in PDF completely (Jasuja (2008).txt)
    - chi2 and RMSEA are too far from each other (Gill (2013))
    - Many models are reported too close to each other (e.g., RMSEA = .04 ... chi2 = 353 ... RMSEA = .06) (Castro-Costa (2008))
    - read "=" as "s" (Carter (2006))